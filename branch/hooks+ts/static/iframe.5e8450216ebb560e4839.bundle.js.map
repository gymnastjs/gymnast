{"version":3,"file":"static/iframe.5e8450216ebb560e4839.bundle.js","sources":["webpack:///webpack://gymnast/webpack/universalModuleDefinition","webpack:///webpack://gymnast/node_modules/cxs/dist/monolithic.js","webpack:///webpack://gymnast/node_modules/cxs/monolithic.js","webpack:///webpack://gymnast/node_modules/lodash/compact.js","webpack:///webpack://gymnast/src/col.tsx","webpack:///webpack://gymnast/src/configProvider/context.tsx","webpack:///webpack://gymnast/src/configProvider/index.tsx","webpack:///webpack://gymnast/src/cxs.tsx","webpack:///webpack://gymnast/src/defaults.tsx","webpack:///webpack://gymnast/src/errors/index.tsx","webpack:///webpack://gymnast/src/errors/jsErrors.js","webpack:///webpack://gymnast/src/errors/preval.js","webpack:///webpack://gymnast/src/grid.tsx","webpack:///webpack://gymnast/src/gymnast.tsx","webpack:///webpack://gymnast/src/log/index.tsx","webpack:///webpack://gymnast/src/useGrid/grid.styles.tsx","webpack:///webpack://gymnast/src/useGrid/index.tsx","webpack:///webpack://gymnast/src/useResolution/index.tsx","webpack:///webpack://gymnast/src/useResolution/mediaQuery.tsx","webpack:///webpack://gymnast/src/useResolution/useResolution.logic.tsx","webpack:///webpack://gymnast/src/utils/index.tsx","webpack:///webpack:/gymnast/external \"react\""],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"react\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"react\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"gymnast\"] = factory(require(\"react\"));\n\telse\n\t\troot[\"gymnast\"] = factory(root[\"react\"]);\n})(window, function(__WEBPACK_EXTERNAL_MODULE_react__) {\nreturn ","'use strict';\n\nvar cache = {};\nvar prefix = '_cxs';\nvar cssRules = [];\nvar insert = function insert(rule) {\n  return cssRules.push(rule);\n};\n\nvar hyph = function hyph(s) {\n  return s.replace(/[A-Z]|^ms/g, '-$&').toLowerCase();\n};\nvar mx = function mx(rule, media) {\n  return media ? media + '{' + rule + '}' : rule;\n};\nvar noAnd = function noAnd(s) {\n  return s.replace(/&/g, '');\n};\nvar createDeclaration = function createDeclaration(key, value) {\n  return hyph(key) + ':' + value;\n};\nvar createRule = function createRule(_ref) {\n  var className = _ref.className,\n      child = _ref.child,\n      media = _ref.media,\n      declarations = _ref.declarations;\n  return mx('.' + (className + child) + '{' + declarations.join(';') + '}', media);\n};\n\nvar parseRules = function parseRules(obj) {\n  var child = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  var media = arguments[2];\n\n  var rules = [];\n  var declarations = [];\n\n  for (var key in obj) {\n    var value = obj[key];\n\n    if (value === null) continue;\n\n    if (typeof value === 'object') {\n      var _media = /^@/.test(key) ? key : null;\n      var _child = _media ? child : child + noAnd(key);\n      parseRules(value, _child, _media).forEach(function (r) {\n        return rules.push(r);\n      });\n      continue;\n    }\n\n    var dec = createDeclaration(key, value);\n    declarations.push(dec);\n  }\n\n  rules.unshift({\n    media: media,\n    child: child,\n    declarations: declarations\n  });\n\n  return rules;\n};\n\nvar parse = function parse(obj) {\n  var rules = parseRules(obj);\n  var classNames = [];\n\n  rules.forEach(function (rule) {\n    var key = JSON.stringify(rule);\n    if (cache[key]) {\n      classNames.push(cache[key]);\n      return;\n    }\n    var className = prefix + cssRules.length.toString(36);\n    classNames.push(className);\n    var ruleset = createRule(Object.assign(rule, { className: className }));\n    insert(ruleset);\n    cache[key] = className;\n  });\n\n  return classNames.join(' ');\n};\n\nmodule.exports = function () {\n  for (var _len = arguments.length, styles = Array(_len), _key = 0; _key < _len; _key++) {\n    styles[_key] = arguments[_key];\n  }\n\n  return styles.map(function (style) {\n    return parse(style);\n  }).join(' ').trim();\n};\n\nmodule.exports.css = function () {\n  return cssRules.sort().join('');\n};\n\nmodule.exports.reset = function () {\n  cache = {};\n  while (cssRules.length) {\n    cssRules.pop();\n  }\n};\n\nmodule.exports.prefix = function (val) {\n  return prefix = val;\n};\n\nif (typeof document !== 'undefined') {\n  var s = document.createElement('style');\n  if (window) s.nonce = window.__webpack_nonce__;\n  var style = document.head.appendChild(s);\n  var sheet = style.sheet;\n  style.id = '_cxs_';\n  insert = function insert(rule) {\n    cssRules.push(rule);\n    sheet.insertRule(rule, sheet.cssRules.length);\n  };\n}","module.exports = require('./dist/monolithic')\n","/**\n * Creates an array with all falsey values removed. The values `false`, `null`,\n * `0`, `\"\"`, `undefined`, and `NaN` are falsey.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to compact.\n * @returns {Array} Returns the new array of filtered values.\n * @example\n *\n * _.compact([0, 1, false, 2, '', 3]);\n * // => [1, 2, 3]\n */\nfunction compact(array) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      resIndex = 0,\n      result = [];\n\n  while (++index < length) {\n    var value = array[index];\n    if (value) {\n      result[resIndex++] = value;\n    }\n  }\n  return result;\n}\n\nmodule.exports = compact;\n","import * as React from 'react'\nimport useGrid from './useGrid'\nimport { GridProps, OneResolutionGrid } from './types'\n\nconst defaultProps: OneResolutionGrid = {\n  marginTop: 0,\n  marginRight: 'gutter/2',\n  marginBottom: 'verticalGutter',\n  marginLeft: 'gutter/2',\n}\n\nconst forwardRef = React.forwardRef(function Col(\n  props: GridProps & JSX.IntrinsicElements['div'],\n  ref: React.RefObject<HTMLDivElement>\n) {\n  const colProps =\n    props.margin !== undefined\n      ? props\n      : {\n          ...defaultProps,\n          ...props,\n        }\n  const [shouldShow, gridProps] = useGrid(colProps)\n\n  return shouldShow ? <div {...gridProps} ref={ref} /> : null\n})\n\nforwardRef.displayName = 'Col'\n\nexport default forwardRef\n","import * as React from 'react'\nimport { ConfigContextType } from '../types'\nimport defaults from '../defaults'\n\nexport default React.createContext<ConfigContextType>(defaults)\n","import * as React from 'react'\nimport { ConfigContextType } from '../types'\nimport Context from './context'\nimport defaults from '../defaults'\n\ntype ProviderProps = ConfigContextType & {\n  children?: React.ReactNode\n}\n\ntype ProviderState = ConfigContextType\n\nclass ConfigProvider extends React.Component<ProviderProps, ProviderState> {\n  static getDerivedStateFromProps(props: ProviderProps, state: ProviderState) {\n    const { children, ...restProps } = props\n\n    return {\n      ...state,\n      ...restProps,\n    }\n  }\n\n  state = defaults\n\n  render() {\n    const { state } = this\n    const { children } = this.props\n\n    return <Context.Provider value={state}>{children}</Context.Provider>\n  }\n}\n\nexport default (props: ProviderProps) => {\n  const context = React.useContext(Context)\n\n  return <ConfigProvider {...context} {...props} />\n}\n","import cxs from 'cxs/monolithic'\n\ncxs.prefix('gym_')\n\nexport default cxs\n","import { ConfigDefaults } from './types.d'\n\nconst defaults: ConfigDefaults = {\n  base: 8, // multiplier (in pixels) that all other size units use\n  columns: 12, // number of columns used in the layout\n  displayAliases: {\n    // aliases used for the different display breakpoints:\n    small: [\n      {\n        //   - \"small\" alias used when width is less than 600px\n        maxWidth: '599px',\n      },\n      {\n        maxDeviceWidth: '599px',\n      },\n    ],\n    medium: [\n      {\n        //   - \"medium\" alias used when width is between 600px and 900px\n        minWidth: '600px',\n        maxWidth: '899px',\n      },\n      {\n        minDeviceWidth: '600px',\n        maxDeviceWidth: '899px',\n      },\n    ],\n    large: [\n      {\n        //   - \"large\" alias used when width is equal or greater than 900px\n        minWidth: '900px',\n      },\n      {\n        minDeviceWidth: '900px',\n      },\n    ],\n  },\n  fallbackDisplayKey: 'default', // key to use when a display alias is omitted or non matching\n  gutter: 3, // value (in base units) that separates columns horizontally\n  spacingAliases: {\n    // aliases used to indicate spacing values (margin/padding) in base\n    XS: 0.5, // units.\n    'S/2': 0.5,\n    S: 1,\n    'M/2': 1,\n    M: 2,\n    'L/2': 1.5,\n    L: 3,\n    'XL/2': 2,\n    XL: 4,\n    '2XL/2': 3,\n    '2XL': 6,\n  },\n  verticalGutter: 3, // value (in base units) that separates columns vertically\n}\n\nexport default defaults\n","const jsErrors = require('./preval.js')\n\nexport const errorKeys = {\n  INVALIDSPACING: 'INVALIDSPACING',\n  MIXEDSPACING: 'MIXEDSPACING',\n  NOMATCHMEDIA: 'NOMATCHMEDIA',\n  TOOMANYSPACEVAL: 'TOOMANYSPACEVAL',\n  INVALIDLOGLEVEL: 'INVALIDLOGLEVEL',\n}\n\nexport const errors: { [errorType: string]: string } = jsErrors\n","function addDevError(acc, code, message) {\n  acc[code] = `${code}: ${message}\n\n    You can find more information here: https://github.com/gymnastjs/gymnast/wiki/${code}`\n  return acc\n}\n\nfunction addProdError(acc, code) {\n  acc[code] = code\n  return acc\n}\nconst addError =\n  process.env.NODE_ENV === 'production' ? addProdError : addDevError\nconst errors = {}\n\naddError(\n  errors,\n  'INVALIDSPACING',\n  `Invalid spacing property type used, only array, undefined, string or numbers allowed.`\n)\naddError(\n  errors,\n  'MIXEDSPACING',\n  `You cannot define margin or padding and a direction at the same time.`\n)\naddError(\n  errors,\n  'NOMATCHMEDIA',\n  `\"window.matchMedia\" is not available in your environment, media queries will not work.`\n)\naddError(\n  errors,\n  'TOOMANYSPACEVAL',\n  `Invalid Spacing size, only first 4 values used. Spacing values follow CSS syntax, this means you can specify 1, 2, 3 or 4 values but not more.`\n)\n\naddError(\n  errors,\n  'INVALIDLOGLEVEL',\n  'Specified logger log level is invalid. Valid values are: \"info\", \"warn\" and \"error\"'\n)\nmodule.exports = errors\n","// @preval\nmodule.exports = require('./jsErrors')\n","import * as React from 'react'\nimport useGrid from './useGrid'\nimport { GridProps } from './types.d'\n\nconst forwardRef = React.forwardRef(function Grid(\n  props: GridProps & JSX.IntrinsicElements['div'],\n  ref: React.RefObject<HTMLDivElement>\n) {\n  const [shouldShow, gridProps] = useGrid(props)\n\n  return shouldShow ? <div {...gridProps} ref={ref} /> : null\n})\n\nforwardRef.displayName = 'Grid'\n\nexport default forwardRef\n","import './cxs'\n\n// Components\nexport { default as Col } from './col'\nexport { default as ConfigProvider } from './configProvider'\nexport { default as Grid } from './grid'\n\n// Hooks\nexport { default as useGrid } from './useGrid'\nexport { default as useResolution } from './useResolution'\n\n// Utils\nexport { default as defaults } from './defaults'\nexport { default as log } from './log'\nexport { default as utils } from './utils'\n\nexport {\n  AlignGrid,\n  DisplayValues,\n  GridProps,\n  Justify,\n  Overflow,\n  Size,\n  Spacing,\n  SpacingProps,\n  SpacingValues,\n} from './types.d'\n","/* eslint-disable no-console */\nimport { errors } from '../errors'\n\nexport type Logger = { info: Function; warn: Function; error: Function }\nconst logLevels = ['info', 'warn', 'error']\nlet logIndex = 0\n\nlet logger: Logger = console\n\nconst log = {\n  info: (...args: any[]) => logIndex <= 0 && logger.info(...args),\n  warn: (...args: any[]) => logIndex <= 1 && logger.warn(...args),\n  error: (...args: any[]) => logIndex <= 2 && logger.error(...args),\n  setLevel(level: 'info' | 'warn' | 'error') {\n    const index = logLevels.indexOf(level)\n\n    if (index >= 0) {\n      logIndex = index\n    } else {\n      log.error(errors.INVALIDLOGLEVEL, level)\n    }\n  },\n  setLogger(newLogger: Logger) {\n    logger = newLogger\n  },\n}\nexport default log\n","import cxs from '../cxs'\nimport { toCXS } from '../utils/index'\n\nexport const styles = toCXS({\n  grid: {\n    border: '0 transparent solid',\n    boxSizing: 'border-box',\n    display: 'flex',\n    flexFlow: 'row wrap',\n    width: '100%',\n  },\n  fraction: {\n    flexGrow: 1,\n  },\n  leftJustify: {\n    justifyContent: 'flex-start',\n    marginRight: 'auto',\n  },\n  centerJustify: {\n    justifyContent: 'center',\n    marginLeft: 'auto',\n    marginRight: 'auto',\n  },\n  rightJustify: {\n    justifyContent: 'flex-end',\n    marginLeft: 'auto',\n  },\n  topAlign: {\n    alignContent: 'flex-start',\n    alignItems: 'flex-start',\n  },\n  centerAlign: {\n    alignContent: 'center',\n    alignItems: 'center',\n  },\n  bottomAlign: {\n    alignContent: 'flex-end',\n    alignItems: 'flex-end',\n  },\n  colAuto: {\n    /* expanded shorthand for Edge */\n    flexGrow: 1,\n    flexShrink: 1,\n    flexBasis: '0%' /* % is required for Edge */,\n  },\n  colFit: {\n    flexGrow: 0,\n    flexShrink: 0,\n    width: 'auto',\n    whiteSpace: 'nowrap',\n  },\n})\n\nexport function getCol(size: string | number | void, columns: number) {\n  if (size === 'auto') {\n    return styles.colAuto\n  }\n\n  if (size === 'fit') {\n    return styles.colFit\n  }\n\n  if (typeof size === 'undefined' || size === 0) {\n    return styles.fraction\n  }\n\n  return cxs({\n    flexBasis: `${(parseInt(`${size}`, 10) / columns) * 100}%`,\n    maxWidth: `${(parseInt(`${size}`, 10) / columns) * 100}%`,\n  })\n}\n","import * as React from 'react'\nimport { compact } from 'lodash'\nimport { combineSpacing, getValues, getValue } from '../utils'\nimport { GridProps, NonGridProps } from '../types'\nimport { styles, getCol } from './grid.styles'\nimport useResolution from '../useResolution'\nimport Context from '../configProvider/context'\n\nconst resolutionProperties = ['align', 'justify', 'size']\n\nexport default function useGrid<A extends {}>(\n  props: GridProps & A\n): [boolean, NonGridProps] {\n  const [\n    shouldRender,\n    {\n      align,\n      className,\n      justify,\n      size,\n      base,\n      margin,\n      marginBottom,\n      marginLeft,\n      marginRight,\n      marginTop,\n      padding,\n      paddingBottom,\n      paddingLeft,\n      paddingRight,\n      paddingTop,\n      style,\n      ...restProps\n    },\n  ] = useResolution(resolutionProperties, props)\n  const context = React.useContext(Context)\n\n  if (!shouldRender) {\n    return [false, { style: {}, className, ...restProps }]\n  }\n  const {\n    gutter,\n    verticalGutter,\n    base: contextBase,\n    spacingAliases,\n  } = getValues(context, props)\n\n  const spacing = combineSpacing({\n    spacingProps: {\n      margin,\n      padding,\n      marginTop,\n      marginRight,\n      marginBottom,\n      marginLeft,\n      paddingTop,\n      paddingRight,\n      paddingBottom,\n      paddingLeft,\n    },\n    base: base === undefined ? contextBase : base,\n    spacingAliases,\n    gutter,\n    verticalGutter,\n  })\n\n  return [\n    true,\n    {\n      style: { ...style, ...spacing },\n      className: compact([\n        styles.grid,\n        getCol(size, getValue(context, 'columns')),\n        className,\n        align && styles[`${align}Align`],\n        justify && styles[`${justify}Justify`],\n      ]).join(' '),\n      ...restProps,\n    },\n  ]\n}\n","import * as React from 'react'\nimport { DisplayAliases, GridProps, OneResolutionGrid } from '../types'\nimport log from '../log'\nimport { getValue } from '../utils'\nimport { errors } from '../errors'\nimport { register, unregister, supportsMatchMedia } from './mediaQuery'\nimport Context from '../configProvider/context'\nimport {\n  checkShouldShow,\n  getMediaQueries,\n  getSingleResolutionProps,\n  hasTrueValues,\n  isObject,\n  ShouldShow,\n  sharedResolutionProperties,\n} from './useResolution.logic'\nimport defaults from '../defaults'\n\nfunction anyPropsUseResolutionFormat(combinedResolutionKeys: string[], props) {\n  return combinedResolutionKeys.some(key => {\n    const { [key]: prop } = props\n\n    return isObject(prop)\n  })\n}\n\nfunction getQueries({ show, combinedResolutionKeys, context, props }) {\n  const displayAliases: DisplayAliases = getValue(context, 'displayAliases')\n  let queries = show\n\n  if (!show && anyPropsUseResolutionFormat(combinedResolutionKeys, props)) {\n    queries = Object.keys(displayAliases)\n  }\n\n  return getMediaQueries(queries, displayAliases)\n}\n\nfunction useMedia(props) {\n  const queries = getQueries(props)\n  const [shouldShow, setShouldShow] = React.useState<ShouldShow>(\n    checkShouldShow(queries)\n  )\n\n  function onMediaQueryChange(mq: any = {}, alias: string) {\n    if (shouldShow[alias] !== mq.matches) {\n      setShouldShow({\n        ...shouldShow,\n        [alias]: mq.matches,\n      })\n    }\n  }\n\n  React.useEffect(() => {\n    Object.keys(queries).forEach(alias => {\n      register(queries[alias], alias, onMediaQueryChange)\n    })\n\n    return () =>\n      Object.keys(queries).forEach(alias => {\n        unregister(queries[alias], onMediaQueryChange)\n      })\n  }, [...Object.values(shouldShow || {}), props.show])\n\n  return shouldShow\n}\n\nexport default function useResolution<A extends GridProps>(\n  resolutionKeys: Array<string>,\n  props: A,\n  allowMatchMedia: boolean = supportsMatchMedia\n): [boolean, A & OneResolutionGrid] {\n  if (!allowMatchMedia) {\n    log.warn(errors.NOMATCHMEDIA)\n    return [\n      true,\n      getSingleResolutionProps({\n        props,\n        shouldShow: undefined,\n        resolutionKeys: [],\n        fallbackDisplayKey: defaults.fallbackDisplayKey,\n      }),\n    ]\n  }\n  const context = React.useContext(Context)\n  const fallbackDisplayKey: string = getValue(context, 'fallbackDisplayKey')\n\n  const { show, ...restProps } = props\n  const combinedResolutionKeys = sharedResolutionProperties.concat(\n    resolutionKeys\n  )\n  const shouldShow = useMedia({\n    show,\n    combinedResolutionKeys,\n    context,\n    props: restProps,\n  })\n\n  if (show && shouldShow && !hasTrueValues(shouldShow)) {\n    return [\n      false,\n      getSingleResolutionProps({\n        props,\n        shouldShow: undefined,\n        resolutionKeys: [],\n        fallbackDisplayKey,\n      }),\n    ]\n  }\n\n  return [\n    true,\n    getSingleResolutionProps({\n      props,\n      shouldShow,\n      resolutionKeys: combinedResolutionKeys,\n      fallbackDisplayKey,\n    }),\n  ]\n}\n","type Callback = (mql: MediaQueryList, alias: string) => void\ntype QueryData = {\n  [query: string]: {\n    readonly mediaQuery: MediaQueryList\n    readonly allCallbacks: (mql: MediaQueryListEvent) => void\n  }\n}\ntype PerCallbackData = {\n  [query: string]: Array<{\n    readonly alias: string\n    readonly callback: Callback\n  }>\n}\n\nconst perCallbackData: PerCallbackData = {}\nconst queryData: QueryData = {}\n\nfunction getCallCallbacks(query: string) {\n  return () => {\n    perCallbackData[query].forEach(({ callback, alias }) =>\n      callback(queryData[query].mediaQuery, alias)\n    )\n  }\n}\n\nexport const supportsMatchMedia = !!(window && window.matchMedia)\n\nexport function register(query: string, alias: string, callback: Callback) {\n  if (!query || !supportsMatchMedia) {\n    return\n  }\n\n  unregister(query, callback)\n\n  if (query in perCallbackData) {\n    perCallbackData[query].push({ callback, alias })\n  } else {\n    const mediaQuery = window.matchMedia(query)\n    const allCallbacks = getCallCallbacks(query)\n\n    queryData[query] = { mediaQuery, allCallbacks }\n    perCallbackData[query] = [{ callback, alias }]\n\n    mediaQuery.addListener(allCallbacks)\n  }\n  callback(queryData[query].mediaQuery, alias)\n}\n\nexport function unregister(query: string, cb: Callback) {\n  if (supportsMatchMedia && query && query in perCallbackData) {\n    perCallbackData[query] = perCallbackData[query].filter(\n      ({ callback }) => cb !== callback\n    )\n\n    if (perCallbackData[query].length === 0) {\n      queryData[query].mediaQuery.removeListener(queryData[query].allCallbacks)\n\n      delete queryData[query]\n      delete perCallbackData[query]\n    }\n  }\n}\n","import { DisplayAliases, DisplayProperties } from '../types'\nimport { splitPattern, kebabCase } from '../utils'\nimport defaults from '../defaults'\n\nexport const sharedResolutionProperties = [\n  'margin',\n  'marginBottom',\n  'marginLeft',\n  'marginRight',\n  'marginTop',\n  'padding',\n  'paddingBottom',\n  'paddingLeft',\n  'paddingRight',\n  'paddingTop',\n]\n\nexport type ShouldShow = { [aliasName: string]: boolean }\n\nfunction isTrue(obj: ShouldShow) {\n  return (key: string) => obj[key] === true\n}\n\nfunction getActiveResolutionName(shouldShow: ShouldShow) {\n  return Object.keys(shouldShow).find(isTrue(shouldShow))\n}\n\nfunction extractObjectValue(\n  value: any,\n  shouldShow: ShouldShow = {},\n  fallbackKey: string\n) {\n  const active = getActiveResolutionName(shouldShow)\n\n  return active && active in value ? value[active] : value[fallbackKey]\n}\n\nexport function isObject(value: any) {\n  return Object.prototype.toString.call(value) === '[object Object]'\n}\n\nexport function hasTrueValues(obj: {} = {}) {\n  return Object.keys(obj).some(isTrue(obj))\n}\n\nexport function getSingleResolutionProps({\n  props,\n  shouldShow,\n  resolutionKeys = [],\n  fallbackDisplayKey = defaults.fallbackDisplayKey,\n}: {\n  readonly props: any\n  readonly shouldShow?: ShouldShow\n  readonly resolutionKeys: string[]\n  readonly fallbackDisplayKey: string\n}) {\n  const { ...propsCopy } = props\n\n  delete propsCopy.show\n\n  Object.keys(propsCopy).forEach(key => {\n    const value = propsCopy[key]\n\n    if (isObject(value) && resolutionKeys.includes(key)) {\n      propsCopy[key] = extractObjectValue(value, shouldShow, fallbackDisplayKey)\n    }\n  })\n\n  return propsCopy\n}\n\nexport function getMediaQuery(\n  range: string,\n  displayAliases: DisplayAliases,\n  prefix: string = '@media '\n): string {\n  const value = displayAliases[range]\n\n  const displayPropertiesArray: DisplayProperties[] = Array.isArray(value)\n    ? value\n    : [value]\n\n  const response = displayPropertiesArray\n    .map(\n      displayProperties =>\n        `${prefix}${Object.keys(displayProperties)\n          .map(key => `(${kebabCase(key)}: ${displayProperties[key]})`)\n          .join(' and ')}`\n    )\n    .join(', ')\n\n  return response\n}\n\nexport function getMediaQueries(\n  show: string | Array<string> = [],\n  displayAliases: DisplayAliases\n): { [key: string]: string } {\n  const showArray = show instanceof Array ? show : show.split(splitPattern)\n\n  return showArray\n    .filter(range => range in displayAliases)\n    .map(range => [range, getMediaQuery(range, displayAliases, '')])\n    .reduce((acc, [range, query]) => {\n      if (query) {\n        return {\n          ...acc,\n          [range]: query,\n        }\n      }\n      return acc\n    }, {})\n}\n\nexport function checkShouldShow(queries: { [alias: string]: string }) {\n  if (Object.keys(queries).length === 0) {\n    return undefined\n  }\n\n  const shouldShow: ShouldShow = {}\n\n  Object.keys(queries).forEach(alias => {\n    shouldShow[alias] = window.matchMedia(queries[alias]).matches\n  })\n\n  return shouldShow\n}\n","import cxs from '../cxs'\nimport defaults from '../defaults'\nimport {\n  Noop,\n  SpacingAliases,\n  SpacingProps,\n  SpacingValues,\n  ConfigDefaults,\n} from '../types'\nimport log from '../log'\nimport { errors } from '../errors'\n\nconst hasDefinedValues = (keys: { [key: string]: any | void }) => (\n  key: string\n) => typeof keys[key] !== 'undefined'\nconst isDefined = (val?: any) => typeof val !== 'undefined'\n// regex case examples: https://regex101.com/r/bs73rZ/1\n\nexport const splitPattern = /(?:(?:\\s+)?,(?:\\s+)?|\\s+)/\nexport const noop: Noop = () => null\nexport const times = (n: number): any[] =>\n  new Array(n).fill(undefined).map((val, index) => index)\nexport const kebabCase = (str: string) =>\n  str\n    .replace(/^[A-Z]/, match => match.toLowerCase())\n    .replace(/[A-Z]/g, match => `-${match.toLowerCase()}`)\n\nexport function validateSpacingProps(\n  props: SpacingProps & {\n    marginArray?: Array<number> | void\n    paddingArray?: Array<number> | void\n  }\n) {\n  if (process.env.NODE_ENV === 'production') {\n    return true\n  }\n\n  const margins = ['marginTop', 'marginRight', 'marginBottom', 'marginLeft']\n  const paddings = [\n    'paddingTop',\n    'paddingRight',\n    'paddingBottom',\n    'paddingLeft',\n  ]\n\n  if (\n    (typeof props.marginArray !== 'undefined' &&\n      margins.some(hasDefinedValues(props))) ||\n    (typeof props.paddingArray !== 'undefined' &&\n      paddings.some(hasDefinedValues(props)))\n  ) {\n    log.error(errors.MIXEDSPACING, `\"${JSON.stringify(props)}\" used`)\n    return false\n  }\n  return true\n}\n\nfunction getSpacing(\n  values: Array<number> | void = [],\n  type: 'margin' | 'padding'\n): { [CSSProp: string]: number } {\n  if (!values || !values.length) {\n    return {}\n  }\n\n  let allValues = []\n\n  switch (values.length) {\n    case 1:\n      allValues = [values[0], values[0], values[0], values[0]]\n      break\n    case 2:\n      allValues = [values[0], values[1], values[0], values[1]]\n      break\n    case 3:\n      allValues = [values[0], values[1], values[2], values[1]]\n      break\n    case 4:\n      allValues = values\n      break\n    default:\n      log.error(errors.TOOMANYSPACEVAL, `\"${JSON.stringify(values)}\" used`)\n      allValues = values\n  }\n\n  return {\n    [`${type}Top`]: allValues[0],\n    [`${type}Right`]: allValues[1],\n    [`${type}Bottom`]: allValues[2],\n    [`${type}Left`]: allValues[3],\n  }\n}\n\nexport function getCSS(\n  prop: string | void,\n  value: number | string | void,\n  base: number\n): { [CSSProp: string]: number } {\n  const num = typeof value === 'number' ? value : parseFloat(value || '0')\n\n  if (!prop || typeof value === 'undefined') {\n    return {}\n  }\n\n  if (prop.includes('padding')) {\n    return { [prop]: num * base }\n  }\n\n  return {\n    [`${prop.replace('margin', 'border')}Width`]: num * base,\n  }\n}\n/**\n * parseSpacing allows using different kinds of input for spacing parameters. Instead of allowing\n * only number arrays, the following are also valid:\n *\n * - arrays of strings or numbers (converted to float):\n *   - `margin={[\"1\", 0, \"0.5\"]}` becomes `[1, 0, 0.5]`\n * - space-separated or comma-separated strings\n *   - `margin=\"0\"` becomes `[0]`\n *   - `margin=\"1 0\"` becomes `[1, 0]`\n *   - `margin=\"1,0\"` becomes `[2, 0]`\n * - numbers\n *   - `margin={1}` becomes `[1]`\n */\n\nexport function parseSpacing(\n  spacing: any,\n  spacingAliases: SpacingAliases | void\n): number[] | void {\n  if (typeof spacing === 'undefined') {\n    return undefined\n  }\n  if (typeof spacing === 'number') {\n    return [spacing]\n  }\n\n  let spacingArray\n  if (spacing instanceof Array) {\n    spacingArray = spacing\n  } else if (typeof spacing === 'string') {\n    spacingArray = spacing.split(splitPattern)\n  }\n  if (spacingArray) {\n    return replaceSpacingAliases(spacingArray, spacingAliases).map(value =>\n      parseFloat(`${value}`)\n    )\n  }\n\n  log.error(errors.INVALIDSPACING, `\"${typeof spacing}\" used`)\n  return undefined\n}\n\nfunction replaceSpacingAlias(\n  value: SpacingValues,\n  spacingAliases: SpacingAliases | void\n) {\n  if (spacingAliases && typeof value === 'string' && value in spacingAliases) {\n    return spacingAliases[value]\n  }\n  return value\n}\n\nexport function replaceSpacingAliases(\n  spacingArray: Array<SpacingValues>,\n  spacingAliases: SpacingAliases | void\n): Array<SpacingValues> {\n  return spacingArray.map(value => replaceSpacingAlias(value, spacingAliases))\n}\n\nfunction replaceSpacingAliasValues({\n  props,\n  spacingAliases,\n}: {\n  props: { [direction: string]: any }\n  spacingAliases: SpacingAliases\n}): { [direction: string]: SpacingValues } {\n  return Object.keys(props).reduce(\n    (acc, key) => ({\n      ...acc,\n      [key]: replaceSpacingAlias(props[key], spacingAliases),\n    }),\n    {}\n  )\n}\n\ntype CombineSpacingSettings = {\n  spacingProps: SpacingProps\n  base: number\n  spacingAliases?: SpacingAliases\n  gutter?: number\n  verticalGutter?: number\n}\n\nexport function combineSpacing({\n  spacingProps,\n  base,\n  spacingAliases,\n  gutter = defaults.gutter,\n  verticalGutter = defaults.verticalGutter,\n}: CombineSpacingSettings) {\n  const combinedSpacingAliases = {\n    ...defaults.spacingAliases,\n    ...spacingAliases,\n    gutter,\n    'gutter/2': gutter / 2,\n    verticalGutter,\n    'verticalGutter/2': verticalGutter / 2,\n  }\n  const { margin, padding, ...props } = spacingProps\n  const marginArray = parseSpacing(margin, combinedSpacingAliases)\n  const paddingArray = parseSpacing(padding, combinedSpacingAliases)\n\n  if (\n    !validateSpacingProps({\n      marginArray,\n      paddingArray,\n      ...props,\n    })\n  ) {\n    return {}\n  }\n\n  const flatProps = {\n    ...replaceSpacingAliasValues({\n      props,\n      spacingAliases: combinedSpacingAliases,\n    }),\n    ...getSpacing(marginArray, 'margin'),\n    ...getSpacing(paddingArray, 'padding'),\n  }\n\n  return Object.keys(flatProps).reduce(\n    (acc, prop) => ({ ...acc, ...getCSS(prop, flatProps[prop], base) }),\n    {}\n  )\n}\n\nexport function toCXS(raw: { [CSSProp: string]: string | number | {} }) {\n  const styles: { [CSSProp: string]: string } = {}\n\n  Object.keys(raw).forEach(style => {\n    styles[style] = cxs(raw[style])\n  })\n\n  return styles\n}\n\nexport function getValue<A>(\n  context: { [key: string]: any } = {},\n  property: keyof ConfigDefaults,\n  override?: A\n): A {\n  return [override, context[property], defaults[property]].find(isDefined)\n}\n\nexport function getValues<C extends object, D extends Object>(\n  context: C | void,\n  overrides: D | void\n) {\n  return { ...defaults, ...(context || {}), ...(overrides || {}) }\n}\n\nexport function accumulateOver(props: Array<string>) {\n  return (acc: any, current: any) => {\n    props.forEach(prop => {\n      acc[prop] = Object.assign(acc[prop], current[prop])\n    })\n    return acc\n  }\n}\n\nexport default {\n  accumulateOver,\n  combineSpacing,\n  getCSS,\n  getValue,\n  getValues,\n  noop,\n  parseSpacing,\n  replaceSpacingAliases,\n  splitPattern,\n  times,\n  toCXS,\n  validateSpacingProps,\n}\n","module.exports = __WEBPACK_EXTERNAL_MODULE_react__;"],"mappings":"AAAA;;;;;ACEA;;;;;ACFA;;AAAA;;;;;AC8BA;;;;;;;;;AC1BA;;;;;ACJA;;AAAA;;AAAA;;;;;;;;;;;ACWA;;;;;ACXA;;AAAA;;;;;ACEA;;;;;ACFA;;AAAA;;;;;ACWA;;;;;ACVA;;AAAA;;;;;;;;;ACGA;;;;;ACJA;;AAAA;;AAAA;;AAAA;;AAAA;;AAAA;;AAAA;;AAAA;;AAAA;;AAAA;;AAAA;;;;;ACAA;;AAAA;;;;;;;;;;ACAA;;AAAA;;AAAA;;;;;;;;;;;;;;;;;ACQA;;;;;;;;;;;;;;;;;;;;;ACkBA;;;;;ACZA;;;;;;;;;ACVA;;;;;;;;;;;;;ACQA;;;;;ACZA","sourceRoot":""}