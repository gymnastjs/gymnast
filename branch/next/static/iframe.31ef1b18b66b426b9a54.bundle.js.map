{"version":3,"file":"static/iframe.31ef1b18b66b426b9a54.bundle.js","sources":["webpack:///webpack://gymnast/webpack/universalModuleDefinition","webpack:///webpack://gymnast/node_modules/cxs/dist/monolithic.js","webpack:///webpack://gymnast/node_modules/cxs/monolithic.js","webpack:///webpack://gymnast/node_modules/lodash/compact.js","webpack:///webpack://gymnast/src/asGrid/grid.styles.js","webpack:///webpack://gymnast/src/asGrid/index.js","webpack:///webpack://gymnast/src/col.js","webpack:///webpack://gymnast/src/configProvider/consumer.js","webpack:///webpack://gymnast/src/configProvider/context.js","webpack:///webpack://gymnast/src/configProvider/index.js","webpack:///webpack://gymnast/src/core/index.js","webpack:///webpack://gymnast/src/cxs.js","webpack:///webpack://gymnast/src/defaults.js","webpack:///webpack://gymnast/src/grid.js","webpack:///webpack://gymnast/src/gymnast.js","webpack:///webpack://gymnast/src/log/index.js","webpack:///webpack://gymnast/src/utils/index.js","webpack:///webpack://gymnast/src/withContext/index.js","webpack:///webpack://gymnast/src/withResolution/index.js","webpack:///webpack://gymnast/src/withResolution/mediaQuery.js","webpack:///webpack://gymnast/src/withResolution/withResolution.logic.js","webpack:///webpack:/gymnast/external \"react\""],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"react\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"react\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"gymnast\"] = factory(require(\"react\"));\n\telse\n\t\troot[\"gymnast\"] = factory(root[\"react\"]);\n})(window, function(__WEBPACK_EXTERNAL_MODULE_react__) {\nreturn ","'use strict';\n\nvar cache = {};\nvar prefix = '_cxs';\nvar cssRules = [];\nvar insert = function insert(rule) {\n  return cssRules.push(rule);\n};\n\nvar hyph = function hyph(s) {\n  return s.replace(/[A-Z]|^ms/g, '-$&').toLowerCase();\n};\nvar mx = function mx(rule, media) {\n  return media ? media + '{' + rule + '}' : rule;\n};\nvar noAnd = function noAnd(s) {\n  return s.replace(/&/g, '');\n};\nvar createDeclaration = function createDeclaration(key, value) {\n  return hyph(key) + ':' + value;\n};\nvar createRule = function createRule(_ref) {\n  var className = _ref.className,\n      child = _ref.child,\n      media = _ref.media,\n      declarations = _ref.declarations;\n  return mx('.' + (className + child) + '{' + declarations.join(';') + '}', media);\n};\n\nvar parseRules = function parseRules(obj) {\n  var child = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  var media = arguments[2];\n\n  var rules = [];\n  var declarations = [];\n\n  for (var key in obj) {\n    var value = obj[key];\n\n    if (value === null) continue;\n\n    if (typeof value === 'object') {\n      var _media = /^@/.test(key) ? key : null;\n      var _child = _media ? child : child + noAnd(key);\n      parseRules(value, _child, _media).forEach(function (r) {\n        return rules.push(r);\n      });\n      continue;\n    }\n\n    var dec = createDeclaration(key, value);\n    declarations.push(dec);\n  }\n\n  rules.unshift({\n    media: media,\n    child: child,\n    declarations: declarations\n  });\n\n  return rules;\n};\n\nvar parse = function parse(obj) {\n  var rules = parseRules(obj);\n  var classNames = [];\n\n  rules.forEach(function (rule) {\n    var key = JSON.stringify(rule);\n    if (cache[key]) {\n      classNames.push(cache[key]);\n      return;\n    }\n    var className = prefix + cssRules.length.toString(36);\n    classNames.push(className);\n    var ruleset = createRule(Object.assign(rule, { className: className }));\n    insert(ruleset);\n    cache[key] = className;\n  });\n\n  return classNames.join(' ');\n};\n\nmodule.exports = function () {\n  for (var _len = arguments.length, styles = Array(_len), _key = 0; _key < _len; _key++) {\n    styles[_key] = arguments[_key];\n  }\n\n  return styles.map(function (style) {\n    return parse(style);\n  }).join(' ').trim();\n};\n\nmodule.exports.css = function () {\n  return cssRules.sort().join('');\n};\n\nmodule.exports.reset = function () {\n  cache = {};\n  while (cssRules.length) {\n    cssRules.pop();\n  }\n};\n\nmodule.exports.prefix = function (val) {\n  return prefix = val;\n};\n\nif (typeof document !== 'undefined') {\n  var s = document.createElement('style');\n  if (window) s.nonce = window.__webpack_nonce__;\n  var style = document.head.appendChild(s);\n  var sheet = style.sheet;\n  style.id = '_cxs_';\n  insert = function insert(rule) {\n    cssRules.push(rule);\n    sheet.insertRule(rule, sheet.cssRules.length);\n  };\n}","module.exports = require('./dist/monolithic')\n","/**\n * Creates an array with all falsey values removed. The values `false`, `null`,\n * `0`, `\"\"`, `undefined`, and `NaN` are falsey.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to compact.\n * @returns {Array} Returns the new array of filtered values.\n * @example\n *\n * _.compact([0, 1, false, 2, '', 3]);\n * // => [1, 2, 3]\n */\nfunction compact(array) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      resIndex = 0,\n      result = [];\n\n  while (++index < length) {\n    var value = array[index];\n    if (value) {\n      result[resIndex++] = value;\n    }\n  }\n  return result;\n}\n\nmodule.exports = compact;\n","// @flow\nimport cxs from '../cxs'\nimport { toCXS } from '../utils/index'\n\nexport const styles = toCXS({\n  grid: {\n    border: '0 transparent solid',\n    boxSizing: 'border-box',\n    display: 'flex',\n    flexFlow: 'row wrap',\n    width: '100%',\n  },\n  fraction: {\n    flexGrow: 1,\n  },\n  leftJustify: {\n    justifyContent: 'flex-start',\n    marginRight: 'auto',\n  },\n  centerJustify: {\n    justifyContent: 'center',\n    marginLeft: 'auto',\n    marginRight: 'auto',\n  },\n  rightJustify: {\n    justifyContent: 'flex-end',\n    marginLeft: 'auto',\n  },\n  topAlign: {\n    alignContent: 'flex-start',\n    alignItems: 'flex-start',\n  },\n  centerAlign: {\n    alignContent: 'center',\n    alignItems: 'center',\n  },\n  bottomAlign: {\n    alignContent: 'flex-end',\n    alignItems: 'flex-end',\n  },\n  colAuto: {\n    /* expanded shorthand for Edge */\n    flexGrow: 1,\n    flexShrink: 1,\n    flexBasis: '0%' /* % is required for Edge */,\n  },\n  colFit: {\n    flexGrow: 0,\n    flexShrink: 0,\n    width: 'auto',\n    whiteSpace: 'nowrap',\n  },\n})\n\nexport function getCol(size: string | number | void, columns: number) {\n  if (size === 'auto') {\n    return styles.colAuto\n  }\n\n  if (size === 'fit') {\n    return styles.colFit\n  }\n\n  if (typeof size === 'undefined' || size === 0) {\n    return styles.fraction\n  }\n\n  return cxs({\n    flexBasis: `${(parseInt(size, 10) / columns) * 100}%`,\n    maxWidth: `${(parseInt(size, 10) / columns) * 100}%`,\n  })\n}\n","// @flow\nimport * as React from 'react'\nimport { compact } from 'lodash'\nimport type { OneResolutionGrid, GridProps, OneResolution } from '../types'\nimport { styles, getCol } from './grid.styles'\nimport { getValue } from '../utils'\nimport getCoreStyles from '../core'\nimport withResolution from '../withResolution'\nimport withContext from '../withContext'\n\nconst resolutionProperties = ['align', 'justify', 'size']\n\nexport default function asGrid(\n  Component: React.ComponentType<*> | string,\n  mapDefaultProps?: (\n    props: $Shape<OneResolution>\n  ) => $Shape<OneResolution> = props => props\n): React.ComponentType<GridProps> {\n  // $FlowFixMe\n  const Grid = React.forwardRef(\n    (\n      {\n        align,\n        className,\n        justify,\n        size,\n        context,\n        ...restProps\n      }: OneResolutionGrid,\n      ref: React$ElementRef<*>\n    ) => {\n      const props = getCoreStyles(mapDefaultProps(restProps), context)\n      const classes = compact([\n        styles.grid,\n        getCol(size, getValue(context, 'columns')),\n        className,\n        align && styles[`${align}Align`],\n        justify && styles[`${justify}Justify`],\n      ])\n\n      return <Component {...props} ref={ref} className={classes.join(' ')} />\n    }\n  )\n\n  const Resolution = withResolution(Grid, resolutionProperties)\n\n  return withContext(Resolution)\n}\n","// @flow\nimport * as React from 'react'\nimport asGrid from './asGrid'\nimport type { GridProps, OneResolution } from './types'\n\nfunction mapProps(props): OneResolution {\n  const defaultProps: OneResolution = {\n    marginTop: 0,\n    marginRight: 'gutter/2',\n    marginBottom: 'verticalGutter',\n    marginLeft: 'gutter/2',\n  }\n\n  return props.margin !== undefined\n    ? props\n    : {\n        ...defaultProps,\n        ...props,\n      }\n}\n\nexport default (asGrid('div', mapProps): React.ComponentType<GridProps>)\n","// @flow\nimport * as React from 'react'\nimport type { ConfigContextType } from '../types'\nimport Context from './context'\n\ntype Props = { children: (context: ConfigContextType) => ?React.Node }\n\nexport default function ConfigConsumer({ children }: Props) {\n  return <Context.Consumer>{context => children(context)}</Context.Consumer>\n}\n","// @flow\nimport * as React from 'react'\nimport type { ConfigContextType } from '../types'\nimport defaults from '../defaults'\n\nconst Context = React.createContext<ConfigContextType>(defaults)\n\nexport default Context\n","// @flow\nimport * as React from 'react'\nimport type { ConfigContextType } from '../types'\nimport Context from './context'\nimport defaults from '../defaults'\n\ntype ProviderProps = {\n  ...ConfigContextType,\n  children?: React.Node,\n}\n\ntype ProviderState = ConfigContextType\n\n// This HOC takes a Provider component and wraps it around a Consumer\n// component that provides non-defaulted values that have been set from preceding\n// Provider components.\nclass ConfigProvider extends React.Component<ProviderProps, ProviderState> {\n  static getDerivedStateFromProps(props: ProviderProps, state: ProviderState) {\n    const { children, ...restProps } = props\n\n    return {\n      ...state,\n      ...restProps,\n    }\n  }\n\n  state = defaults\n\n  render() {\n    const { state } = this\n    const { children } = this.props\n\n    return <Context.Provider value={state}>{children}</Context.Provider>\n  }\n}\n\nexport default (props: ProviderProps) => (\n  <Context.Consumer>\n    {context => <ConfigProvider {...context} {...props} />}\n  </Context.Consumer>\n)\n","// @flow\nimport { combineSpacing, getValues } from '../utils'\nimport type { ConfigContextType, OneResolution } from '../types'\n\nexport default function getCoreStyles(\n  props: $Shape<OneResolution>,\n  context: ?ConfigContextType\n) {\n  const {\n    base,\n    margin,\n    marginBottom,\n    marginLeft,\n    marginRight,\n    marginTop,\n    padding,\n    paddingBottom,\n    paddingLeft,\n    paddingRight,\n    paddingTop,\n    style,\n    ...restProps\n  } = props\n\n  const {\n    gutter,\n    verticalGutter,\n    base: contextBase,\n    spacingAliases,\n  } = getValues(context, props)\n\n  const spacing = combineSpacing({\n    spacingProps: {\n      margin,\n      padding,\n      marginTop,\n      marginRight,\n      marginBottom,\n      marginLeft,\n      paddingTop,\n      paddingRight,\n      paddingBottom,\n      paddingLeft,\n    },\n    base: base === undefined ? contextBase : base,\n    spacingAliases,\n    gutter,\n    verticalGutter,\n  })\n\n  const spacingStyles = { ...style, ...spacing }\n\n  return { ...restProps, style: spacingStyles }\n}\n","// @flow\nimport cxs from 'cxs/monolithic'\n\ncxs.prefix('gym_')\n\nexport default cxs\n","// @flow\nimport { type ConfigContextType } from './types'\n\nconst defaults: {|\n  ...ConfigContextType,\n  gutter: number,\n  fallbackDisplayKey: string,\n  verticalGutter: number,\n|} = {\n  base: 8, // multiplier (in pixels) that all other size units use\n  columns: 12, // number of columns used in the layout\n  displayAliases: {\n    // aliases used for the different display breakpoints:\n    small: [\n      {\n        //   - \"small\" alias used when width is less than 600px\n        maxWidth: '599px',\n      },\n      {\n        maxDeviceWidth: '599px',\n      },\n    ],\n    medium: [\n      {\n        //   - \"medium\" alias used when width is between 600px and 900px\n        minWidth: '600px',\n        maxWidth: '899px',\n      },\n      {\n        minDeviceWidth: '600px',\n        maxDeviceWidth: '899px',\n      },\n    ],\n    large: [\n      {\n        //   - \"large\" alias used when width is equal or greater than 900px\n        minWidth: '900px',\n      },\n      {\n        minDeviceWidth: '900px',\n      },\n    ],\n  },\n  fallbackDisplayKey: 'default', // key to use when a display alias is omitted or non matching\n  gutter: 3, // value (in base units) that separates columns horizontally\n  spacingAliases: {\n    // aliases used to indicate spacing values (margin/padding) in base\n    XS: 0.5, // units.\n    'S/2': 0.5,\n    S: 1,\n    'M/2': 1,\n    M: 2,\n    'L/2': 1.5,\n    L: 3,\n    'XL/2': 2,\n    XL: 4,\n    '2XL/2': 3,\n    '2XL': 6,\n  },\n  verticalGutter: 3, // value (in base units) that separates columns vertically\n}\n\nexport default defaults\n","// @flow\nimport * as React from 'react'\nimport asGrid from './asGrid'\nimport type { GridProps } from './types'\n\nexport default (asGrid('div'): React.ComponentType<GridProps>)\n","// @flow\nimport './cxs'\n\n// Components\nexport { default as Col } from './col'\nexport { default as ConfigProvider } from './configProvider'\nexport { default as Grid } from './grid'\n\n// HOC\nexport { default as asGrid } from './asGrid'\nexport { default as withContext } from './withContext'\nexport { default as withResolution } from './withResolution'\n\n// Utils\nexport { default as defaults } from './defaults'\nexport { default as log } from './log'\nexport { default as utils } from './utils'\n\n// Types\nexport type {\n  AlignGrid,\n  DisplayValues,\n  GridProps,\n  Justify,\n  Overflow,\n  Size,\n  Spacing,\n  SpacingProps,\n  SpacingValues,\n} from './types'\n","// @flow\n/* eslint-disable no-console */\nimport errors from '../errors'\n\ntype LogLevels = 'info' | 'warn' | 'error'\nconst logLevels = ['info', 'warn', 'error']\nlet logIndex = 0\nlet logger = console\nconst log = {}\n\nlogLevels.forEach((level, index) => {\n  log[level] = (...args: any[]) => {\n    if (index >= logIndex) {\n      logger[level](...args)\n    }\n  }\n})\n\nlog.setLevel = (level: LogLevels) => {\n  const index = logLevels.indexOf(level)\n\n  if (index >= 0) {\n    logIndex = index\n  } else {\n    log.error(errors.INVALIDLOGLEVEL, level)\n  }\n}\n\nlog.setLogger = (newLogger: { [LogLevels]: (...args: any[]) => void }) => {\n  logger = newLogger\n}\n\nexport default log\n","// @flow\nimport cxs from '../cxs'\nimport defaults from '../defaults'\nimport type {\n  Noop,\n  SpacingAliases,\n  SpacingProps,\n  SpacingValues,\n} from '../types'\nimport log from '../log'\nimport errors from '../errors'\n\nconst hasDefinedValues = keys => key => typeof keys[key] !== 'undefined'\nconst isDefined = val => typeof val !== 'undefined'\n// regex case examples: https://regex101.com/r/bs73rZ/1\n\nexport const splitPattern = /(?:(?:\\s+)?,(?:\\s+)?|\\s+)/\nexport const noop: Noop = () => null\nexport const times = (n: number): Array<*> =>\n  new Array(n).fill(undefined).map((val, index) => index)\nexport const kebabCase = (str: string) =>\n  str\n    .replace(/^[A-Z]/, match => match.toLowerCase())\n    .replace(/[A-Z]/g, match => `-${match.toLowerCase()}`)\n\nexport function validateSpacingProps(\n  props: SpacingProps & {\n    marginArray?: Array<number>,\n    paddingArray?: Array<number>,\n  }\n) {\n  if (process.env.NODE_ENV === 'production') {\n    return true\n  }\n\n  const margins = ['marginTop', 'marginRight', 'marginBottom', 'marginLeft']\n  const paddings = [\n    'paddingTop',\n    'paddingRight',\n    'paddingBottom',\n    'paddingLeft',\n  ]\n\n  if (\n    (typeof props.marginArray !== 'undefined' &&\n      margins.some(hasDefinedValues(props))) ||\n    (typeof props.paddingArray !== 'undefined' &&\n      paddings.some(hasDefinedValues(props)))\n  ) {\n    log.error(errors.MIXEDSPACING, `\"${JSON.stringify(props)}\" used`)\n    return false\n  }\n  return true\n}\n\nfunction getSpacing(\n  values?: Array<number> = [],\n  type: 'margin' | 'padding'\n): { [string]: number } {\n  if (!values || !values.length) {\n    return {}\n  }\n\n  let allValues = []\n\n  switch (values.length) {\n    case 1:\n      allValues = [values[0], values[0], values[0], values[0]]\n      break\n    case 2:\n      allValues = [values[0], values[1], values[0], values[1]]\n      break\n    case 3:\n      allValues = [values[0], values[1], values[2], values[1]]\n      break\n    case 4:\n      allValues = values\n      break\n    default:\n      log.error(errors.TOOMANYSPACEVAL, `\"${JSON.stringify(values)}\" used`)\n      allValues = values\n  }\n\n  return {\n    [`${type}Top`]: allValues[0],\n    [`${type}Right`]: allValues[1],\n    [`${type}Bottom`]: allValues[2],\n    [`${type}Left`]: allValues[3],\n  }\n}\n\nexport function getCSS(\n  prop: string,\n  value: number | string,\n  base: number\n): { [string]: number } {\n  const num = typeof value === 'number' ? value : parseFloat(value || 0)\n\n  if (typeof value === 'undefined') {\n    return {}\n  }\n\n  if (prop.includes('padding')) {\n    return { [prop]: num * base }\n  }\n\n  return {\n    [`${prop.replace('margin', 'border')}Width`]: num * base,\n  }\n}\n/**\n * parseSpacing allows using different kinds of input for spacing parameters. Instead of allowing\n * only number arrays, the following are also valid:\n *\n * - arrays of strings or numbers (converted to float):\n *   - `margin={[\"1\", 0, \"0.5\"]}` becomes `[1, 0, 0.5]`\n * - space-separated or comma-separated strings\n *   - `margin=\"0\"` becomes `[0]`\n *   - `margin=\"1 0\"` becomes `[1, 0]`\n *   - `margin=\"1,0\"` becomes `[2, 0]`\n * - numbers\n *   - `margin={1}` becomes `[1]`\n */\n\nexport function parseSpacing(\n  spacing: any,\n  spacingAliases: SpacingAliases\n): number[] | void {\n  if (typeof spacing === 'undefined') {\n    return undefined\n  }\n  if (typeof spacing === 'number') {\n    return [spacing]\n  }\n\n  let spacingArray\n  if (spacing instanceof Array) {\n    spacingArray = spacing\n  } else if (typeof spacing === 'string') {\n    spacingArray = spacing.split(splitPattern)\n  }\n  if (spacingArray) {\n    return replaceSpacingAliases(spacingArray, spacingAliases).map(parseFloat)\n  }\n\n  log.error(errors.INVALIDSPACING, `\"${typeof spacing}\" used`)\n  return undefined\n}\n\nfunction replaceSpacingAlias(\n  value: SpacingValues,\n  spacingAliases: SpacingAliases\n) {\n  if (spacingAliases && typeof value === 'string' && value in spacingAliases) {\n    return spacingAliases[value]\n  }\n  return value\n}\n\nexport function replaceSpacingAliases(\n  spacingArray: Array<SpacingValues>,\n  spacingAliases: SpacingAliases\n): Array<SpacingValues> {\n  return spacingArray.map(value => replaceSpacingAlias(value, spacingAliases))\n}\n\nfunction replaceSpacingAliasValues({\n  props,\n  spacingAliases,\n}: {\n  props: { [string]: SpacingValues },\n  spacingAliases: SpacingAliases,\n}): { [string]: SpacingValues } {\n  return Object.keys(props).reduce(\n    (acc, key) => ({\n      ...acc,\n      [key]: replaceSpacingAlias(props[key], spacingAliases),\n    }),\n    {}\n  )\n}\n\ntype CombineSpacingSettings = {\n  spacingProps: SpacingProps,\n  base: number,\n  spacingAliases?: SpacingAliases,\n  gutter: number,\n  verticalGutter: number,\n}\n\nexport function combineSpacing({\n  spacingProps,\n  base,\n  spacingAliases,\n  gutter = defaults.gutter,\n  verticalGutter = defaults.verticalGutter,\n}: CombineSpacingSettings) {\n  const combinedSpacingAliases = {\n    ...defaults.spacingAliases,\n    ...spacingAliases,\n    gutter,\n    'gutter/2': gutter / 2,\n    verticalGutter,\n    'verticalGutter/2': verticalGutter / 2,\n  }\n  const { margin, padding, ...props } = spacingProps\n  const marginArray = parseSpacing(margin, combinedSpacingAliases)\n  const paddingArray = parseSpacing(padding, combinedSpacingAliases)\n\n  if (\n    !validateSpacingProps({\n      marginArray,\n      paddingArray,\n      ...props,\n    })\n  ) {\n    return {}\n  }\n\n  const flatProps = {\n    ...replaceSpacingAliasValues({\n      props,\n      spacingAliases: combinedSpacingAliases,\n    }),\n    ...getSpacing(marginArray, 'margin'),\n    ...getSpacing(paddingArray, 'padding'),\n  }\n\n  return Object.keys(flatProps).reduce(\n    (acc, prop) => ({ ...acc, ...getCSS(prop, flatProps[prop], base) }),\n    {}\n  )\n}\n\nexport function toCXS(raw: {\n  +[string]: string | number | {},\n}): { +[string]: string } {\n  const styles = {}\n\n  Object.keys(raw).forEach(style => {\n    styles[style] = cxs(raw[style])\n  })\n\n  return styles\n}\n\nexport function getValue<A: *>(context: *, property: string, override?: A): A {\n  return ([override, context[property], defaults[property]].find(\n    isDefined\n  ): any)\n}\n\nexport function getValues(context: *, overrides?: * = {}) {\n  return { ...defaults, ...context, ...overrides }\n}\n\nexport function accumulateOver(props: Array<string>) {\n  return (acc: *, current: *) => {\n    props.forEach(prop => {\n      acc[prop] = Object.assign(acc[prop], current[prop])\n    })\n    return acc\n  }\n}\n\nexport default {\n  accumulateOver,\n  combineSpacing,\n  getCSS,\n  getValue,\n  getValues,\n  noop,\n  parseSpacing,\n  replaceSpacingAliases,\n  splitPattern,\n  times,\n  toCXS,\n  validateSpacingProps,\n}\n","// @flow\nimport * as React from 'react'\nimport ConfigConsumer from '../configProvider/consumer'\n\nexport default function withContext(Component: React.ComponentType<*>) {\n  // $FlowFixMe\n  return React.forwardRef(\n    (props: React.ElementProps<typeof Component>, ref: React$ElementRef<*>) => (\n      <ConfigConsumer>\n        {context => <Component {...props} context={context} ref={ref} />}\n      </ConfigConsumer>\n    )\n  )\n}\n","// @flow\nimport * as React from 'react'\nimport type { DisplayValues } from '../types'\nimport log from '../log'\nimport { getValue } from '../utils'\nimport errors from '../errors'\nimport { register, unregister, supportsMatchMedia } from './mediaQuery'\nimport {\n  checkShouldShow,\n  getMediaQueries,\n  getSingleResolutionProps,\n  hasTrueValues,\n  isObject,\n  type ShouldShow,\n  sharedResolutionProperties,\n} from './withResolution.logic'\n\ntype Props = { show?: DisplayValues }\ntype State = {\n  shouldShow?: ShouldShow,\n}\n\nexport default function withResolution(\n  Component: React.ComponentType<*>,\n  resolutionKeys: Array<string>,\n  coercedSupport?: boolean = supportsMatchMedia\n) {\n  const combinedResolutionKeys = sharedResolutionProperties.concat(\n    resolutionKeys\n  )\n\n  if (!coercedSupport) {\n    log.warn(errors.NOMATCHMEDIA)\n    return Component\n  }\n\n  type InternalProps = Props & {|\n    innerRef: React$ElementRef<*>,\n  |}\n  class WithResolution extends React.Component<\n    InternalProps & React.ElementProps<typeof Component>,\n    State\n  > {\n    static defaultProps = { context: {} }\n\n    constructor(props: InternalProps) {\n      super(props)\n      const queries = this.getQueries(props.show)\n\n      this.state = {\n        shouldShow: checkShouldShow(queries),\n      }\n    }\n\n    componentDidMount() {\n      const { show } = this.props\n      this.addMediaQueryListener(show)\n    }\n\n    componentWillReceiveProps(nextProps: InternalProps) {\n      const { show } = this.props\n      if (nextProps.show !== show) {\n        this.removeMediaQueryListener(show)\n        this.addMediaQueryListener(nextProps.show)\n      }\n    }\n\n    componentWillUnmount() {\n      const { show } = this.props\n      this.removeMediaQueryListener(show)\n    }\n\n    onMediaQueryChange = (mq?: any = {}, alias: string) => {\n      const { shouldShow = {} } = this.state\n\n      if (shouldShow[alias] !== mq.matches) {\n        this.setState({\n          shouldShow: {\n            ...shouldShow,\n            [alias]: mq.matches,\n          },\n        })\n      }\n    }\n\n    getQueries = (show?: DisplayValues) => {\n      const { context } = this.props\n      const displayAliases = getValue(context, 'displayAliases')\n      let queries = show\n\n      if (!show && this.anyPropsUseResolutionFormat()) {\n        queries = Object.keys(displayAliases)\n      }\n\n      return getMediaQueries(queries, displayAliases)\n    }\n\n    anyPropsUseResolutionFormat = () =>\n      combinedResolutionKeys.some(key => {\n        const { [key]: prop } = this.props\n\n        return isObject(prop)\n      })\n\n    removeMediaQueryListener = (show?: DisplayValues) => {\n      const queries = this.getQueries(show)\n\n      Object.keys(queries).forEach(alias => {\n        unregister(queries[alias], this.onMediaQueryChange)\n      })\n    }\n\n    addMediaQueryListener = (show?: DisplayValues) => {\n      const queries = this.getQueries(show)\n\n      Object.keys(queries).forEach(alias => {\n        register(queries[alias], alias, this.onMediaQueryChange)\n      })\n    }\n\n    render() {\n      const { context, show, innerRef, ...restProps } = this.props\n      const { shouldShow } = this.state\n\n      if (show && shouldShow && !hasTrueValues(shouldShow)) {\n        return null\n      }\n\n      const props = getSingleResolutionProps({\n        props: restProps,\n        shouldShow,\n        resolutionKeys: combinedResolutionKeys,\n        fallbackDisplayKey: getValue(context, 'fallbackDisplayKey'),\n      })\n\n      return (\n        <Component {...props} ref={innerRef} show={show} context={context} />\n      )\n    }\n  }\n\n  // $FlowFixMe\n  return React.forwardRef((props, ref) => (\n    <WithResolution {...props} innerRef={ref} />\n  ))\n}\n","// @flow\ntype Callback = (mql: MediaQueryList, alias: string) => void\ntype QueryData = {\n  [query: string]: {|\n    +mediaQuery: MediaQueryList,\n    +allCallbacks: (mql: MediaQueryListEvent) => void,\n  |},\n}\ntype PerCallbackData = {\n  [query: string]: Array<{|\n    +alias: string,\n    +callback: Callback,\n  |}>,\n}\n\nconst perCallbackData: PerCallbackData = {}\nconst queryData: QueryData = {}\n\nfunction getCallCallbacks(query) {\n  return () => {\n    perCallbackData[query].forEach(({ callback, alias }) =>\n      callback(queryData[query].mediaQuery, alias)\n    )\n  }\n}\n\nexport const supportsMatchMedia = !!(window && window.matchMedia)\n\nexport function register(query: string, alias: string, callback: Callback) {\n  if (!query || !supportsMatchMedia) {\n    return\n  }\n\n  unregister(query, callback)\n\n  if (query in perCallbackData) {\n    perCallbackData[query].push({ callback, alias })\n  } else {\n    const mediaQuery = window.matchMedia(query)\n    const allCallbacks = getCallCallbacks(query)\n\n    queryData[query] = { mediaQuery, allCallbacks }\n    perCallbackData[query] = [{ callback, alias }]\n\n    mediaQuery.addListener(allCallbacks)\n  }\n  callback(queryData[query].mediaQuery, alias)\n}\n\nexport function unregister(query: string, cb: Callback) {\n  if (supportsMatchMedia && query && query in perCallbackData) {\n    perCallbackData[query] = perCallbackData[query].filter(\n      ({ callback }) => cb !== callback\n    )\n\n    if (perCallbackData[query].length === 0) {\n      queryData[query].mediaQuery.removeListener(queryData[query].allCallbacks)\n\n      delete queryData[query]\n      delete perCallbackData[query]\n    }\n  }\n}\n","// @flow\nimport type { DisplayAliases } from '../types'\nimport { splitPattern, kebabCase } from '../utils'\nimport defaults from '../defaults'\n\nexport const sharedResolutionProperties = [\n  'margin',\n  'marginBottom',\n  'marginLeft',\n  'marginRight',\n  'marginTop',\n  'padding',\n  'paddingBottom',\n  'paddingLeft',\n  'paddingRight',\n  'paddingTop',\n]\n\nexport type ShouldShow = { [string]: boolean }\n\nfunction isTrue(obj) {\n  return (key: string) => obj[key] === true\n}\n\nfunction getActiveResolutionName(shouldShow: ShouldShow) {\n  return Object.keys(shouldShow).find(isTrue(shouldShow))\n}\n\nfunction extractObjectValue(\n  value: any,\n  shouldShow?: ShouldShow = {},\n  fallbackKey: string\n) {\n  const active = getActiveResolutionName(shouldShow)\n\n  return active && active in value ? value[active] : value[fallbackKey]\n}\n\nexport function isObject(value: any) {\n  return Object.prototype.toString.call(value) === '[object Object]'\n}\n\nexport function hasTrueValues(obj: {} = {}) {\n  return Object.keys(obj).some(isTrue(obj))\n}\n\nexport function getSingleResolutionProps({\n  props,\n  shouldShow,\n  resolutionKeys = [],\n  fallbackDisplayKey = defaults.fallbackDisplayKey,\n}: {|\n  +props: *,\n  +shouldShow?: ShouldShow,\n  +resolutionKeys: Array<string>,\n  +fallbackDisplayKey: string,\n|}) {\n  const { ...propsCopy } = props\n\n  delete propsCopy.show\n\n  Object.keys(propsCopy).forEach(key => {\n    const value = propsCopy[key]\n\n    if (isObject(value) && resolutionKeys.includes(key)) {\n      propsCopy[key] = extractObjectValue(value, shouldShow, fallbackDisplayKey)\n    }\n  })\n\n  return propsCopy\n}\n\nexport function getMediaQuery(\n  range: string,\n  displayAliases: DisplayAliases,\n  prefix: string = '@media '\n): string {\n  const displayPropertiesArray =\n    displayAliases[range] instanceof Array\n      ? displayAliases[range]\n      : [displayAliases[range]]\n  const response = displayPropertiesArray\n    .map(\n      displayProperties =>\n        `${prefix}${Object.keys(displayProperties)\n          .map(key => `(${kebabCase(key)}: ${displayProperties[key]})`)\n          .join(' and ')}`\n    )\n    .join(', ')\n\n  return response\n}\n\nexport function getMediaQueries(\n  show: string | Array<string> = [],\n  displayAliases: DisplayAliases\n): { [string]: string } {\n  const showArray = show instanceof Array ? show : show.split(splitPattern)\n\n  return showArray\n    .filter(range => range in displayAliases)\n    .map(range => [range, getMediaQuery(range, displayAliases, '')])\n    .reduce((acc, [range, query]) => {\n      if (query) {\n        return {\n          ...acc,\n          [range]: query,\n        }\n      }\n      return acc\n    }, {})\n}\n\nexport function checkShouldShow(queries: { [alias: string]: string }) {\n  if (Object.keys(queries).length === 0) {\n    return undefined\n  }\n\n  const shouldShow = {}\n\n  Object.keys(queries).forEach(alias => {\n    shouldShow[alias] = window.matchMedia(queries[alias]).matches\n  })\n\n  return shouldShow\n}\n","module.exports = __WEBPACK_EXTERNAL_MODULE_react__;"],"mappings":"AAAA;;;;;ACEA;;;;;ACFA;;AAAA;;;;;AC8BA;;;;;AC7BA;;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;ACSA;;;;;;;;;ACWA;;;;;ACpBA;;AAAA;;AAAA;;;;;ACAA;;AAAA;;AAAA;;;;;;;;;;;ACeA;;;;;;;ACZA;;;;;ACHA;;AAAA;;;;;ACEA;;;;;;;;;;ACFA;;AAAA;;AAAA;;;;;ACAA;;AAAA;;AAAA;;AAAA;;AAAA;;AAAA;;AAAA;;AAAA;;AAAA;;AAAA;;AAAA;;;;;ACAA;;AAAA;;;;;;;;;;;;;ACWA;;;;;;;;;ACRA;;;;;;;;;;;;;;;;;ACkBA;;;;;ACPA;;;;;;;;;ACVA;;;;;ACLA","sourceRoot":""}